diff -urN tcp_wrappers_7.6.orig/Makefile tcp_wrappers_7.6/Makefile
--- tcp_wrappers_7.6.orig/Makefile	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/Makefile	Thu Aug 19 16:45:07 1999
@@ -144,7 +144,7 @@
 linux:
 	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
 	LIBS= RANLIB=ranlib ARFLAGS=rv AUX_OBJ= \
-	NETGROUP= TLI= EXTRA_CFLAGS="$(RPM_OPT_FLAGS) -DSYS_ERRLIST_DEFINED -DBROKEN_SO_LINGER" all
+	NETGROUP= TLI= EXTRA_CFLAGS="$(RPM_OPT_FLAGS) -DINET6 -DSYS_ERRLIST_DEFINED -DBROKEN_SO_LINGER" all
 
 # This is good for many SYSV+BSD hybrids with NIS, probably also for HP-UX 7.x.
 hpux hpux8 hpux9 hpux10:
@@ -457,7 +457,7 @@
 # host name aliases. Compile with -DSOLARIS_24_GETHOSTBYNAME_BUG to work
 # around this. The workaround does no harm on other Solaris versions.
 
-BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DLIBC_CALLS_STRTOK
+#BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DLIBC_CALLS_STRTOK
 #BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DINET_ADDR_BUG
 #BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DSOLARIS_24_GETHOSTBYNAME_BUG
 
@@ -475,7 +475,7 @@
 # If your system supports vsyslog(), comment out the following definition.
 # If in doubt leave it in, it won't harm.
 
-VSYSLOG	= -Dvsyslog=myvsyslog
+#VSYSLOG	= -Dvsyslog=myvsyslog
 
 # End of the system dependencies.
 #################################
diff -urN tcp_wrappers_7.6.orig/fix_options.c tcp_wrappers_7.6/fix_options.c
--- tcp_wrappers_7.6.orig/fix_options.c	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/fix_options.c	Thu Aug 19 16:44:31 1999
@@ -11,6 +11,9 @@
 
 #include <sys/types.h>
 #include <sys/param.h>
+#if defined(INET6) && defined(linux)
+#include <sys/socket.h>
+#endif
 #include <netinet/in.h>
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
diff -urN tcp_wrappers_7.6.orig/hosts_access.5 tcp_wrappers_7.6/hosts_access.5
--- tcp_wrappers_7.6.orig/hosts_access.5	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/hosts_access.5	Thu Aug 19 16:44:31 1999
@@ -85,10 +85,17 @@
 for daemon process names or for client user names.
 .IP \(bu
 An expression of the form `n.n.n.n/m.m.m.m\' is interpreted as a
-`net/mask\' pair. A host address is matched if `net\' is equal to the
+`net/mask\' pair. A IPv4 host address is matched if `net\' is equal to the
 bitwise AND of the address and the `mask\'. For example, the net/mask
 pattern `131.155.72.0/255.255.254.0\' matches every address in the
 range `131.155.72.0\' through `131.155.73.255\'.
+.IP \(bu
+An expression of the form `[n:n:n:n:n:n:n:n]/m\' is interpreted as a
+`[net]/prefixlen\' pair. A IPv6 host address is matched if
+`prefixlen\' bits of `net\' is equal to the `prefixlen\' bits of the
+address. For example, the [net]/prefixlen pattern
+`[3ffe:505:2:1::]/64\' matches every address in the range
+`3ffe:505:2:1::\' through `3ffe:505:2:1:ffff:ffff:ffff:ffff\'.
 .SH WILDCARDS
 The access control language supports explicit wildcards:
 .IP ALL
diff -urN tcp_wrappers_7.6.orig/hosts_access.c tcp_wrappers_7.6/hosts_access.c
--- tcp_wrappers_7.6.orig/hosts_access.c	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/hosts_access.c	Thu Aug 19 16:44:31 1999
@@ -25,6 +25,9 @@
 
 #include <sys/types.h>
 #include <sys/param.h>
+#ifdef INET6
+#include <sys/socket.h>
+#endif
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <stdio.h>
@@ -82,6 +85,10 @@
 static int host_match();
 static int string_match();
 static int masked_match();
+#ifdef INET6
+static int masked_match4();
+static int masked_match6();
+#endif
 
 /* Size of logical line buffer. */
 
@@ -289,6 +296,13 @@
 {
     int     n;
 
+#ifdef INET6
+    /* convert IPv4 mapped IPv6 address to IPv4 address */
+    if (STRN_EQ(string, "::ffff:", 7)
+	&& dot_quad_addr(string + 7) != INADDR_NONE) {
+	string += 7;
+    }
+#endif
     if (tok[0] == '.') {			/* suffix */
 	n = strlen(string) - strlen(tok);
 	return (n > 0 && STR_EQ(tok, string + n));
@@ -299,20 +313,55 @@
     } else if (tok[(n = strlen(tok)) - 1] == '.') {	/* prefix */
 	return (STRN_EQ(tok, string, n));
     } else {					/* exact match */
+#ifdef INET6
+	struct in6_addr pat, addr;
+	int len, ret;
+	char ch;
+
+	len = strlen(tok);
+	if (*tok == '[' && tok[len - 1] == ']') {
+	    ch = tok[len - 1];
+	    tok[len - 1] = '\0';
+	    ret = inet_pton(AF_INET6, tok + 1, pat.s6_addr);
+	    tok[len - 1] = ch;
+	    if (ret != 1 || inet_pton(AF_INET6, string, addr.s6_addr) != 1)
+		return NO;
+	    return (!memcmp(&pat, &addr, sizeof(struct in6_addr)));
+	}
+#endif
 	return (STR_EQ(tok, string));
     }
 }
 
 /* masked_match - match address against netnumber/netmask */
 
+#ifdef INET6
 static int masked_match(net_tok, mask_tok, string)
 char   *net_tok;
 char   *mask_tok;
 char   *string;
 {
+    return (masked_match4(net_tok, mask_tok, string) ||
+	    masked_match6(net_tok, mask_tok, string));
+}
+
+static int masked_match4(net_tok, mask_tok, string)
+#else
+static int masked_match(net_tok, mask_tok, string)
+#endif
+char   *net_tok;
+char   *mask_tok;
+char   *string;
+{
+#ifdef INET6
+    u_int32_t net;
+    u_int32_t mask;
+    u_int32_t addr;
+#else
     unsigned long net;
     unsigned long mask;
     unsigned long addr;
+#endif
 
     /*
      * Disallow forms other than dotted quad: the treatment that inet_addr()
@@ -324,8 +373,61 @@
 	return (NO);
     if ((net = dot_quad_addr(net_tok)) == INADDR_NONE
 	|| (mask = dot_quad_addr(mask_tok)) == INADDR_NONE) {
+#ifndef INET6
 	tcpd_warn("bad net/mask expression: %s/%s", net_tok, mask_tok);
+#endif
 	return (NO);				/* not tcpd_jump() */
     }
     return ((addr & mask) == net);
 }
+
+#ifdef INET6
+static int masked_match6(net_tok, mask_tok, string)
+char   *net_tok;
+char   *mask_tok;
+char   *string;
+{
+    struct in6_addr net, addr;
+    u_int32_t mask;
+    int len, mask_len, i = 0;
+    char ch;
+
+    if (inet_pton(AF_INET6, string, addr.s6_addr) != 1)
+	    return NO;
+
+    if (IN6_IS_ADDR_V4MAPPED(&addr)) {
+	if ((net.s6_addr32[3] = dot_quad_addr(net_tok)) == INADDR_NONE
+	 || (mask = dot_quad_addr(mask_tok)) == INADDR_NONE)
+	    return (NO);
+	return ((addr.s6_addr32[3] & mask) == net.s6_addr32[3]);
+    }
+
+    /* match IPv6 address against netnumber/prefixlen */
+    len = strlen(net_tok);
+    if (*net_tok != '[' || net_tok[len - 1] != ']')
+	return NO;
+    ch = net_tok[len - 1];
+    net_tok[len - 1] = '\0';
+    if (inet_pton(AF_INET6, net_tok + 1, net.s6_addr) != 1) {
+	net_tok[len - 1] = ch;
+	return NO;
+    }
+    net_tok[len - 1] = ch;
+    if ((mask_len = atoi(mask_tok)) < 0 || mask_len > 128)
+	return NO;
+
+    while (mask_len > 0) {
+	if (mask_len < 32) {
+	    mask = htonl(~(0xffffffff >> mask_len));
+	    if ((addr.s6_addr32[i] & mask) != (net.s6_addr32[i] & mask))
+		return NO;
+	    break;
+	}
+	if (addr.s6_addr32[i] != net.s6_addr32[i])
+	    return NO;
+	++i;
+	mask_len -= 32;
+    }
+    return YES;
+}
+#endif /* INET6 */
diff -urN tcp_wrappers_7.6.orig/inetcf.c tcp_wrappers_7.6/inetcf.c
--- tcp_wrappers_7.6.orig/inetcf.c	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/inetcf.c	Thu Aug 19 16:44:31 1999
@@ -26,6 +26,9 @@
   * guesses. Shorter names follow longer ones.
   */
 char   *inet_files[] = {
+#ifdef INET6
+    "/usr/local/v6/etc/inet6d.conf",	/* KAME */
+#endif
     "/private/etc/inetd.conf",		/* NEXT */
     "/etc/inet/inetd.conf",		/* SYSV4 */
     "/usr/etc/inetd.conf",		/* IRIX?? */
diff -urN tcp_wrappers_7.6.orig/misc.c tcp_wrappers_7.6/misc.c
--- tcp_wrappers_7.6.orig/misc.c	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/misc.c	Thu Aug 19 16:44:31 1999
@@ -10,6 +10,9 @@
 
 #include <sys/types.h>
 #include <sys/param.h>
+#if defined(INET6) && defined(linux)
+#include <sys/socket.h>
+#endif
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <stdio.h>
@@ -58,9 +61,31 @@
 {
     char   *cp;
 
+#ifdef INET6
+    int bracket = 0;
+
+    for (cp = string; cp && *cp; cp++) {
+	switch (*cp) {
+	case '[':
+	    bracket++;
+	    break;
+	case ']':
+	    bracket--;
+	    break;
+	default:
+	    if (bracket == 0 && *cp == delimiter) {
+		*cp++ = 0;
+		return cp;
+	    }
+	    break;
+	}
+    }
+    return (NULL);
+#else
     if ((cp = strchr(string, delimiter)) != 0)
 	*cp++ = 0;
     return (cp);
+#endif
 }
 
 /* dot_quad_addr - convert dotted quad to internal form */
diff -urN tcp_wrappers_7.6.orig/refuse.c tcp_wrappers_7.6/refuse.c
--- tcp_wrappers_7.6.orig/refuse.c	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/refuse.c	Thu Aug 19 16:44:32 1999
@@ -25,7 +25,12 @@
 void    refuse(request)
 struct request_info *request;
 {
+#ifdef INET6
+    syslog(deny_severity, "refused connect from %s (%s)",
+	   eval_client(request), eval_hostaddr(request->client));
+#else
     syslog(deny_severity, "refused connect from %s", eval_client(request));
+#endif
     clean_exit(request);
     /* NOTREACHED */
 }
diff -urN tcp_wrappers_7.6.orig/rfc931.c tcp_wrappers_7.6/rfc931.c
--- tcp_wrappers_7.6.orig/rfc931.c	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/rfc931.c	Thu Aug 19 16:44:32 1999
@@ -68,20 +68,50 @@
 /* rfc931 - return remote user name, given socket structures */
 
 void    rfc931(rmt_sin, our_sin, dest)
+#ifdef INET6
+union tcpd_sockunion *rmt_sin;
+union tcpd_sockunion *our_sin;
+#else
 struct sockaddr_in *rmt_sin;
 struct sockaddr_in *our_sin;
+#endif
 char   *dest;
 {
     unsigned rmt_port;
     unsigned our_port;
+#ifdef INET6
+    union  tcpd_sockunion rmt_query_sin;
+    union  tcpd_sockunion our_query_sin;
+    int alen;
+#else
     struct sockaddr_in rmt_query_sin;
     struct sockaddr_in our_query_sin;
+#endif
     char    user[256];			/* XXX */
     char    buffer[512];		/* XXX */
     char   *cp;
     char   *result = unknown;
     FILE   *fp;
 
+#ifdef INET6
+    /* address family must be the same */
+    if (rmt_sin->su_si.si_family != our_sin->su_si.si_family) {
+	STRN_CPY(dest, result, STRING_LENGTH);
+	return;
+    }
+    switch (rmt_sin->su_si.si_family) {
+    case AF_INET:
+	alen = sizeof(struct sockaddr_in);
+	break;
+    case AF_INET6:
+	alen = sizeof(struct sockaddr_in6);
+	break;
+    default:
+	STRN_CPY(dest, result, STRING_LENGTH);
+	return;
+    }
+#endif
+
     /*
      * Use one unbuffered stdio stream for writing to and for reading from
      * the RFC931 etc. server. This is done because of a bug in the SunOS
@@ -92,7 +122,11 @@
      * sockets.
      */
 
+#ifdef INET6
+    if ((fp = fsocket(our_sin->su_si.si_family, SOCK_STREAM, 0)) != 0) {
+#else
     if ((fp = fsocket(AF_INET, SOCK_STREAM, 0)) != 0) {
+#endif
 	setbuf(fp, (char *) 0);
 
 	/*
@@ -113,6 +147,14 @@
 	     */
 
 	    our_query_sin = *our_sin;
+#ifdef INET6
+	    our_query_sin.su_si.si_port = htons(ANY_PORT);
+	    rmt_query_sin = *rmt_sin;
+	    rmt_query_sin.su_si.si_port = htons(RFC931_PORT);
+
+	    if (bind(fileno(fp), &our_query_sin.su_sa, alen) >= 0 &&
+		connect(fileno(fp), &rmt_query_sin.su_sa, alen) >= 0) {
+#else
 	    our_query_sin.sin_port = htons(ANY_PORT);
 	    rmt_query_sin = *rmt_sin;
 	    rmt_query_sin.sin_port = htons(RFC931_PORT);
@@ -121,6 +163,7 @@
 		     sizeof(our_query_sin)) >= 0 &&
 		connect(fileno(fp), (struct sockaddr *) & rmt_query_sin,
 			sizeof(rmt_query_sin)) >= 0) {
+#endif
 
 		/*
 		 * Send query to server. Neglect the risk that a 13-byte
@@ -129,8 +172,13 @@
 		 */
 
 		fprintf(fp, "%u,%u\r\n",
+#ifdef INET6
+			ntohs(rmt_sin->su_si.si_port),
+			ntohs(our_sin->su_si.si_port));
+#else
 			ntohs(rmt_sin->sin_port),
 			ntohs(our_sin->sin_port));
+#endif
 		fflush(fp);
 
 		/*
@@ -144,8 +192,13 @@
 		    && ferror(fp) == 0 && feof(fp) == 0
 		    && sscanf(buffer, "%u , %u : USERID :%*[^:]:%255s",
 			      &rmt_port, &our_port, user) == 3
+#ifdef INET6
+		    && ntohs(rmt_sin->su_si.si_port) == rmt_port
+		    && ntohs(our_sin->su_si.si_port) == our_port) {
+#else
 		    && ntohs(rmt_sin->sin_port) == rmt_port
 		    && ntohs(our_sin->sin_port) == our_port) {
+#endif
 
 		    /*
 		     * Strip trailing carriage return. It is part of the
diff -urN tcp_wrappers_7.6.orig/scaffold.c tcp_wrappers_7.6/scaffold.c
--- tcp_wrappers_7.6.orig/scaffold.c	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/scaffold.c	Thu Aug 19 16:44:32 1999
@@ -20,6 +20,9 @@
 #include <syslog.h>
 #include <setjmp.h>
 #include <string.h>
+#if defined(INET6) && !defined(USE_GETIPNODEBY)
+#include <resolv.h>
+#endif
 
 #ifndef INADDR_NONE
 #define	INADDR_NONE	(-1)		/* XXX should be 0xffffffff */
@@ -57,6 +60,9 @@
 	 /* void */ ;
 
     if ((hb = (struct hostent_block *) malloc(sizeof(struct hostent_block)
+#ifdef INET6
+			 + strlen(hp->h_name) + 1
+#endif
 			 + (hp->h_length + sizeof(char *)) * count)) == 0) {
 	fprintf(stderr, "Sorry, out of memory\n");
 	exit(1);
@@ -66,6 +72,11 @@
     hb->host.h_addr_list = hb->addr_list;
     hb->host.h_addr_list[count] = 0;
     data = (char *) (hb->host.h_addr_list + count + 1);
+#ifdef INET6
+    hb->host.h_name = data + hp->h_length * count;
+    strcpy(hb->host.h_name, hp->h_name);
+    hb->host.h_addrtype = hp->h_addrtype;
+#endif
 
     for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
 	hb->host.h_addr_list[count] = data + hp->h_length * count;
@@ -74,6 +85,97 @@
     return (&hb->host);
 }
 
+#if defined(INET6) && !defined(USE_GETIPNODEBY)
+/* merge_hostent - merge hostent in one memory block */
+
+static struct hostent *merge_hostent(hp1, hp2)
+struct hostent *hp1, *hp2;
+{
+    struct hostent_block {
+	struct hostent host;
+	char   *addr_list[1];
+    };
+    struct hostent_block *hb;
+    int     count, count2;
+    char   *data;
+    char   *addr;
+
+    for (count = 0; hp1->h_addr_list[count] != 0; count++)
+	 /* void */ ;
+    for (count2 = 0; hp2->h_addr_list[count2] != 0; count2++)
+	 /* void */ ;
+    count += count2;
+
+    if ((hb = (struct hostent_block *) malloc(sizeof(struct hostent_block)
+			 + strlen(hp1->h_name) + 1
+			 + (hp1->h_length + sizeof(char *)) * count)) == 0) {
+	fprintf(stderr, "Sorry, out of memory\n");
+	exit(1);
+    }
+    memset((char *) &hb->host, 0, sizeof(hb->host));
+    hb->host.h_length = hp1->h_length;
+    hb->host.h_addr_list = hb->addr_list;
+    hb->host.h_addr_list[count] = 0;
+    data = (char *) (hb->host.h_addr_list + count + 1);
+    hb->host.h_name = data + hp1->h_length * count;
+    strcpy(hb->host.h_name, hp1->h_name);
+    hb->host.h_addrtype = hp1->h_addrtype;
+
+    for (count = 0; (addr = hp1->h_addr_list[count]) != 0; count++) {
+	hb->host.h_addr_list[count] = data + hp1->h_length * count;
+	memcpy(hb->host.h_addr_list[count], addr, hp1->h_length);
+    }
+    for (count2 = 0; (addr = hp2->h_addr_list[count2]) != 0; count2++) {
+	hb->host.h_addr_list[count] = data + hp1->h_length * count;
+	memcpy(hb->host.h_addr_list[count], addr, hp1->h_length);
+	++count;
+    }
+    return (&hb->host);
+}
+#endif
+
+static struct hostent *gethostbyname64(host)
+char *host;
+{
+    struct hostent *hp, *hp2;
+#ifdef USE_GETIPNODEBY
+    int h_error;
+
+    if ((hp = getipnodebyname(host, AF_INET6,
+			      AI_V4MAPPED | AI_ADDRCONFIG | AI_ALL,
+			      &h_error)) != 0) {
+	hp2 = dup_hostent(hp);
+	freehostent(hp);
+	return (hp2);
+    }
+#else
+    struct hostent *hp1;
+
+    if ((_res.options & RES_INIT) == 0) {
+	if (res_init() < 0) {
+	    tcpd_warn("%s: res_init() failed", host);
+	    return (NULL);
+	}
+    }
+    _res.options |= RES_USE_INET6;
+    if ((hp1 = gethostbyname2(host, AF_INET6)) != NULL)
+	hp1 = dup_hostent(hp1);
+    if ((hp2 = gethostbyname2(host, AF_INET)) != NULL)
+	hp2 = dup_hostent(hp2);
+    if (hp1 && hp2) {
+	hp = merge_hostent(hp1, hp2);
+	free((char *) hp1);
+	free((char *) hp2);
+	return (hp);
+    }
+    if (hp1)
+	return (hp1);
+    if (hp2)
+	return (hp2);
+#endif
+    return (NULL);
+}
+
 /* find_inet_addr - find all addresses for this host, result to free() */
 
 struct hostent *find_inet_addr(host)
@@ -91,6 +193,9 @@
 	h.h_addr_list = addr_list;
 	h.h_addr_list[0] = (char *) &addr;
 	h.h_length = sizeof(addr);
+#ifdef INET6
+	h.h_addrtype = AF_INET;
+#endif
 	return (dup_hostent(&h));
     }
 
@@ -104,19 +209,33 @@
 	tcpd_warn("%s: not an internet address", host);
 	return (0);
     }
+#ifdef INET6
+    if ((hp = gethostbyname64(host)) == 0) {
+#else
     if ((hp = gethostbyname(host)) == 0) {
+#endif
 	tcpd_warn("%s: host not found", host);
 	return (0);
     }
+#ifdef INET6
+    if (hp->h_addrtype != AF_INET6) {
+	tcpd_warn("%d: not an internet host", hp->h_addrtype);
+	free((char *) hp);
+#else
     if (hp->h_addrtype != AF_INET) {
 	tcpd_warn("%d: not an internet host", hp->h_addrtype);
+#endif
 	return (0);
     }
     if (STR_NE(host, hp->h_name)) {
 	tcpd_warn("%s: hostname alias", host);
 	tcpd_warn("(official name: %.*s)", STRING_LENGTH, hp->h_name);
     }
+#ifdef INET6
+    return (hp);
+#else
     return (dup_hostent(hp));
+#endif
 }
 
 /* check_dns - give each address thorough workout, return address count */
@@ -125,7 +244,13 @@
 char   *host;
 {
     struct request_info request;
+#ifdef INET6
+    union tcpd_sockunion sin;
+    char *ap;
+    int alen;
+#else
     struct sockaddr_in sin;
+#endif
     struct hostent *hp;
     int     count;
     char   *addr;
@@ -135,10 +260,30 @@
     request_init(&request, RQ_CLIENT_SIN, &sin, 0);
     sock_methods(&request);
     memset((char *) &sin, 0, sizeof(sin));
+#ifdef INET6
+    sin.su_si.si_family = hp->h_addrtype;
+    switch (hp->h_addrtype) {
+    case AF_INET:
+	ap = (char *)&sin.su_sin.sin_addr;
+	alen = sizeof(struct sockaddr_in);
+	break;
+    case AF_INET6:
+	ap = (char *)&sin.su_sin6.sin6_addr;
+	alen = sizeof(struct sockaddr_in6);
+	break;
+    default:
+	return (0);
+    }
+#else
     sin.sin_family = AF_INET;
+#endif
 
     for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
+#ifdef INET6
+	memcpy(ap, addr, alen);
+#else
 	memcpy((char *) &sin.sin_addr, addr, sizeof(sin.sin_addr));
+#endif
 
 	/*
 	 * Force host name and address conversions. Use the request structure
diff -urN tcp_wrappers_7.6.orig/socket.c tcp_wrappers_7.6/socket.c
--- tcp_wrappers_7.6.orig/socket.c	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/socket.c	Thu Aug 19 16:44:32 1999
@@ -30,6 +30,12 @@
 #include <syslog.h>
 #include <string.h>
 
+#ifdef INET6
+#ifndef USE_GETIPNODEBY
+#include <resolv.h>
+#endif
+#endif
+
 extern char *inet_ntoa();
 
 /* Local stuff. */
@@ -74,8 +80,13 @@
 void    sock_host(request)
 struct request_info *request;
 {
+#ifdef INET6
+    static union tcpd_sockunion client;
+    static union tcpd_sockunion server;
+#else
     static struct sockaddr_in client;
     static struct sockaddr_in server;
+#endif
     int     len;
     char    buf[BUFSIZ];
     int     fd = request->fd;
@@ -125,10 +136,33 @@
 void    sock_hostaddr(host)
 struct host_info *host;
 {
+#ifdef INET6
+    union tcpd_sockunion *sin = host->sin;
+    int alen;
+    char *ap;
+
+    if (!sin)
+	return;
+    switch (sin->su_si.si_family) {
+    case AF_INET:
+	ap = (char *)&sin->su_sin.sin_addr;
+	alen = sizeof(struct in_addr);
+	break;
+    case AF_INET6:
+	ap = (char *)&sin->su_sin6.sin6_addr;
+	alen = sizeof(struct in6_addr);
+	break;
+    default:
+	return;
+    }
+    host->addr[0] = '\0';
+    inet_ntop(sin->su_si.si_family, ap, host->addr, sizeof(host->addr));
+#else
     struct sockaddr_in *sin = host->sin;
 
     if (sin != 0)
 	STRN_CPY(host->addr, inet_ntoa(sin->sin_addr), sizeof(host->addr));
+#endif
 }
 
 /* sock_hostname - map endpoint address to host name */
@@ -136,8 +170,19 @@
 void    sock_hostname(host)
 struct host_info *host;
 {
+#ifdef INET6
+    union tcpd_sockunion *sin = host->sin;
+    char addr[128];
+#ifdef USE_GETIPNODEBY
+    int h_error;
+#endif
+    struct hostent *hp = NULL;
+    char *ap;
+    int alen;
+#else
     struct sockaddr_in *sin = host->sin;
     struct hostent *hp;
+#endif
     int     i;
 
     /*
@@ -147,11 +192,57 @@
      * have to special-case 0.0.0.0, in order to avoid false alerts from the
      * host name/address checking code below.
      */
+#ifdef INET6
+    if (sin != NULL) {
+	switch (sin->su_si.si_family) {
+	case AF_INET:
+	    if (sin->su_sin.sin_addr.s_addr == 0) {
+		strcpy(host->name, paranoid);	/* name is bad, clobber it */
+		return;
+	    }
+	    ap = (char *) &sin->su_sin.sin_addr;
+	    alen = sizeof(struct in_addr);
+	    break;
+	case AF_INET6:
+	    ap = (char *) &sin->su_sin6.sin6_addr;
+	    alen = sizeof(struct in6_addr);
+	    break;
+	defalut:
+	    strcpy(host->name, paranoid);	/* name is bad, clobber it */
+	    return;
+	}
+#ifndef USE_GETIPNODEBY
+	if ((_res.options & RES_INIT) == 0) {
+	    if (res_init() < 0) {
+		inet_ntop(sin->su_si.si_family, ap, addr, sizeof(addr));
+		tcpd_warn("can't verify hostname: res_init() for %s failed",
+			  addr);
+		strcpy(host->name, paranoid);	/* name is bad, clobber it */
+		return;
+	    }
+	}
+	if (sin->su_si.si_family == AF_INET6)
+	    _res.options |= RES_USE_INET6;
+	else
+	    _res.options &= ~RES_USE_INET6;
+#endif
+#ifdef USE_GETIPNODEBY
+	hp = getipnodebyaddr(ap, alen, sin->su_si.si_family, &h_error);
+#else
+	hp = gethostbyaddr(ap, alen, sin->su_si.si_family);
+#endif
+    }
+    if (hp) {
+#else
     if (sin != 0 && sin->sin_addr.s_addr != 0
 	&& (hp = gethostbyaddr((char *) &(sin->sin_addr),
 			       sizeof(sin->sin_addr), AF_INET)) != 0) {
+#endif
 
 	STRN_CPY(host->name, hp->h_name, sizeof(host->name));
+#if defined(INET6) && defined(USE_GETIPNODEBY)
+	freehostent(hp);
+#endif
 
 	/*
 	 * Verify that the address is a member of the address list returned
@@ -166,15 +257,39 @@
 	 * we're in big trouble anyway.
 	 */
 
+#ifdef INET6
+#ifdef USE_GETIPNODEBY
+	hp = getipnodebyname(host->name, sin->su_si.si_family,
+			     AI_V4MAPPED | AI_ADDRCONFIG | AI_ALL, &h_error);
+#else
+	hp = gethostbyname2(host->name,
+			    (sin->su_si.si_family == AF_INET6 &&
+			     IN6_IS_ADDR_V4MAPPED(&sin->su_sin6.sin6_addr)) ?
+				AF_INET : sin->su_si.si_family);
+#endif
+	if (!hp) {
+#else
 	if ((hp = gethostbyname(host->name)) == 0) {
+#endif
 
 	    /*
 	     * Unable to verify that the host name matches the address. This
 	     * may be a transient problem or a botched name server setup.
 	     */
 
+#ifdef INET6
+#ifdef USE_GETIPNODEBY
+	    tcpd_warn("can't verify hostname: getipnodebyname(%s, %s) failed",
+#else
+	    tcpd_warn("can't verify hostname: gethostbyname2(%s, %s) failed",
+#endif
+		      host->name,
+		      (sin->su_si.si_family == AF_INET) ?
+			  "AF_INET" : "AF_INET6");
+#else
 	    tcpd_warn("can't verify hostname: gethostbyname(%s) failed",
 		      host->name);
+#endif
 
 	} else if (STR_NE(host->name, hp->h_name)
 		   && STR_NE(host->name, "localhost")) {
@@ -198,10 +313,19 @@
 	     */
 
 	    for (i = 0; hp->h_addr_list[i]; i++) {
+#ifdef INET6
+		if (memcmp(hp->h_addr_list[i], ap, alen) == 0) {
+#ifdef USE_GETIPNODEBY
+		    freehostent(hp);
+#endif
+		    return;			/* name is good, keep it */
+		}
+#else
 		if (memcmp(hp->h_addr_list[i],
 			   (char *) &sin->sin_addr,
 			   sizeof(sin->sin_addr)) == 0)
 		    return;			/* name is good, keep it */
+#endif
 	    }
 
 	    /*
@@ -210,10 +334,20 @@
 	     * server.
 	     */
 
+#ifdef INET6
+	    inet_ntop(sin->su_si.si_family, ap, addr, sizeof(addr));
+	    tcpd_warn("host name/address mismatch: %s != %.*s",
+		      addr, STRING_LENGTH, hp->h_name);
+#else
 	    tcpd_warn("host name/address mismatch: %s != %.*s",
 		      inet_ntoa(sin->sin_addr), STRING_LENGTH, hp->h_name);
+#endif
 	}
 	strcpy(host->name, paranoid);		/* name is bad, clobber it */
+#if defined(INET6) && defined(USE_GETIPNODEBY)
+	if (hp)
+	    freehostent(hp);
+#endif
     }
 }
 
@@ -223,7 +357,11 @@
 int     fd;
 {
     char    buf[BUFSIZ];
+#ifdef INET6
+    union tcpd_sockunion sin;
+#else
     struct sockaddr_in sin;
+#endif
     int     size = sizeof(sin);
 
     /*
diff -urN tcp_wrappers_7.6.orig/tcp_wrappers-ipv6-1.5.patch tcp_wrappers_7.6/tcp_wrappers-ipv6-1.5.patch
--- tcp_wrappers_7.6.orig/tcp_wrappers-ipv6-1.5.patch	Thu Jan  1 01:00:00 1970
+++ tcp_wrappers_7.6/tcp_wrappers-ipv6-1.5.patch	Thu Aug 19 16:43:24 1999
@@ -0,0 +1,1152 @@
+;; IPv6 patch for tcp_wrappers_7.6 1.5
+;; Aug 14, 1999 by Hajimu UMEMOTO <ume@mahoroba.org>
+;;
+;; This patch supports IPv4/IPv6 dual stack and IPv4-mapped IPv6 address.
+;; You can replace stock tcpd or libwrap.a with this.
+;; IPv6 address pattern is as a `[net]/prefixlen' pair.
+;; This patch was tested on KAME/FreeBSD, KAME/FreeBSD3, KAME/NetBSD,
+;; RedHat 5.1 with kernel 2.1.126, and RedHat 6.0 with kernel 2.2.10.
+;;
+;; CAUTION:
+;; Back out change for field separater.  Now, field separater is `:'
+;; not `|'.  To specify IPv6 address, enclose IPv6 address with `['
+;; and `]'.
+
+Index: src/tcp_wrappers/Makefile
+diff -u src/tcp_wrappers/Makefile:1.1.1.1 src/tcp_wrappers/Makefile:1.5
+--- src/tcp_wrappers/Makefile:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/Makefile	Fri Aug 13 21:28:06 1999
+@@ -454,7 +463,7 @@
+ # host name aliases. Compile with -DSOLARIS_24_GETHOSTBYNAME_BUG to work
+ # around this. The workaround does no harm on other Solaris versions.
+ 
+-BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DLIBC_CALLS_STRTOK
++#BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DLIBC_CALLS_STRTOK
+ #BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DINET_ADDR_BUG
+ #BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DSOLARIS_24_GETHOSTBYNAME_BUG
+ 
+@@ -472,7 +481,7 @@
+ # If your system supports vsyslog(), comment out the following definition.
+ # If in doubt leave it in, it won't harm.
+ 
+-VSYSLOG	= -Dvsyslog=myvsyslog
++#VSYSLOG	= -Dvsyslog=myvsyslog
+ 
+ # End of the system dependencies.
+ #################################
+Index: src/tcp_wrappers/fix_options.c
+diff -u src/tcp_wrappers/fix_options.c:1.1.1.1 src/tcp_wrappers/fix_options.c:1.2
+--- src/tcp_wrappers/fix_options.c:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/fix_options.c	Thu Jul 29 04:22:40 1999
+@@ -11,6 +11,9 @@
+ 
+ #include <sys/types.h>
+ #include <sys/param.h>
++#if defined(INET6) && defined(linux)
++#include <sys/socket.h>
++#endif
+ #include <netinet/in.h>
+ #include <netinet/in_systm.h>
+ #include <netinet/ip.h>
+Index: src/tcp_wrappers/hosts_access.5
+diff -u src/tcp_wrappers/hosts_access.5:1.1.1.1 src/tcp_wrappers/hosts_access.5:1.3
+--- src/tcp_wrappers/hosts_access.5:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/hosts_access.5	Fri Aug 13 20:09:20 1999
+@@ -85,10 +85,17 @@
+ for daemon process names or for client user names.
+ .IP \(bu
+ An expression of the form `n.n.n.n/m.m.m.m\' is interpreted as a
+-`net/mask\' pair. A host address is matched if `net\' is equal to the
++`net/mask\' pair. A IPv4 host address is matched if `net\' is equal to the
+ bitwise AND of the address and the `mask\'. For example, the net/mask
+ pattern `131.155.72.0/255.255.254.0\' matches every address in the
+ range `131.155.72.0\' through `131.155.73.255\'.
++.IP \(bu
++An expression of the form `[n:n:n:n:n:n:n:n]/m\' is interpreted as a
++`[net]/prefixlen\' pair. A IPv6 host address is matched if
++`prefixlen\' bits of `net\' is equal to the `prefixlen\' bits of the
++address. For example, the [net]/prefixlen pattern
++`[3ffe:505:2:1::]/64\' matches every address in the range
++`3ffe:505:2:1::\' through `3ffe:505:2:1:ffff:ffff:ffff:ffff\'.
+ .SH WILDCARDS
+ The access control language supports explicit wildcards:
+ .IP ALL
+Index: src/tcp_wrappers/hosts_access.c
+diff -u src/tcp_wrappers/hosts_access.c:1.1.1.1 src/tcp_wrappers/hosts_access.c:1.11
+--- src/tcp_wrappers/hosts_access.c:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/hosts_access.c	Sat Aug 14 04:02:26 1999
+@@ -25,6 +25,9 @@
+ 
+ #include <sys/types.h>
+ #include <sys/param.h>
++#ifdef INET6
++#include <sys/socket.h>
++#endif
+ #include <netinet/in.h>
+ #include <arpa/inet.h>
+ #include <stdio.h>
+@@ -82,6 +85,10 @@
+ static int host_match();
+ static int string_match();
+ static int masked_match();
++#ifdef INET6
++static int masked_match4();
++static int masked_match6();
++#endif
+ 
+ /* Size of logical line buffer. */
+ 
+@@ -289,6 +296,13 @@
+ {
+     int     n;
+ 
++#ifdef INET6
++    /* convert IPv4 mapped IPv6 address to IPv4 address */
++    if (STRN_EQ(string, "::ffff:", 7)
++	&& dot_quad_addr(string + 7) != INADDR_NONE) {
++	string += 7;
++    }
++#endif
+     if (tok[0] == '.') {			/* suffix */
+ 	n = strlen(string) - strlen(tok);
+ 	return (n > 0 && STR_EQ(tok, string + n));
+@@ -299,20 +313,55 @@
+     } else if (tok[(n = strlen(tok)) - 1] == '.') {	/* prefix */
+ 	return (STRN_EQ(tok, string, n));
+     } else {					/* exact match */
++#ifdef INET6
++	struct in6_addr pat, addr;
++	int len, ret;
++	char ch;
++
++	len = strlen(tok);
++	if (*tok == '[' && tok[len - 1] == ']') {
++	    ch = tok[len - 1];
++	    tok[len - 1] = '\0';
++	    ret = inet_pton(AF_INET6, tok + 1, pat.s6_addr);
++	    tok[len - 1] = ch;
++	    if (ret != 1 || inet_pton(AF_INET6, string, addr.s6_addr) != 1)
++		return NO;
++	    return (!memcmp(&pat, &addr, sizeof(struct in6_addr)));
++	}
++#endif
+ 	return (STR_EQ(tok, string));
+     }
+ }
+ 
+ /* masked_match - match address against netnumber/netmask */
+ 
++#ifdef INET6
+ static int masked_match(net_tok, mask_tok, string)
+ char   *net_tok;
+ char   *mask_tok;
+ char   *string;
+ {
++    return (masked_match4(net_tok, mask_tok, string) ||
++	    masked_match6(net_tok, mask_tok, string));
++}
++
++static int masked_match4(net_tok, mask_tok, string)
++#else
++static int masked_match(net_tok, mask_tok, string)
++#endif
++char   *net_tok;
++char   *mask_tok;
++char   *string;
++{
++#ifdef INET6
++    u_int32_t net;
++    u_int32_t mask;
++    u_int32_t addr;
++#else
+     unsigned long net;
+     unsigned long mask;
+     unsigned long addr;
++#endif
+ 
+     /*
+      * Disallow forms other than dotted quad: the treatment that inet_addr()
+@@ -324,8 +373,61 @@
+ 	return (NO);
+     if ((net = dot_quad_addr(net_tok)) == INADDR_NONE
+ 	|| (mask = dot_quad_addr(mask_tok)) == INADDR_NONE) {
++#ifndef INET6
+ 	tcpd_warn("bad net/mask expression: %s/%s", net_tok, mask_tok);
++#endif
+ 	return (NO);				/* not tcpd_jump() */
+     }
+     return ((addr & mask) == net);
+ }
++
++#ifdef INET6
++static int masked_match6(net_tok, mask_tok, string)
++char   *net_tok;
++char   *mask_tok;
++char   *string;
++{
++    struct in6_addr net, addr;
++    u_int32_t mask;
++    int len, mask_len, i = 0;
++    char ch;
++
++    if (inet_pton(AF_INET6, string, addr.s6_addr) != 1)
++	    return NO;
++
++    if (IN6_IS_ADDR_V4MAPPED(&addr)) {
++	if ((net.s6_addr32[3] = dot_quad_addr(net_tok)) == INADDR_NONE
++	 || (mask = dot_quad_addr(mask_tok)) == INADDR_NONE)
++	    return (NO);
++	return ((addr.s6_addr32[3] & mask) == net.s6_addr32[3]);
++    }
++
++    /* match IPv6 address against netnumber/prefixlen */
++    len = strlen(net_tok);
++    if (*net_tok != '[' || net_tok[len - 1] != ']')
++	return NO;
++    ch = net_tok[len - 1];
++    net_tok[len - 1] = '\0';
++    if (inet_pton(AF_INET6, net_tok + 1, net.s6_addr) != 1) {
++	net_tok[len - 1] = ch;
++	return NO;
++    }
++    net_tok[len - 1] = ch;
++    if ((mask_len = atoi(mask_tok)) < 0 || mask_len > 128)
++	return NO;
++
++    while (mask_len > 0) {
++	if (mask_len < 32) {
++	    mask = htonl(~(0xffffffff >> mask_len));
++	    if ((addr.s6_addr32[i] & mask) != (net.s6_addr32[i] & mask))
++		return NO;
++	    break;
++	}
++	if (addr.s6_addr32[i] != net.s6_addr32[i])
++	    return NO;
++	++i;
++	mask_len -= 32;
++    }
++    return YES;
++}
++#endif /* INET6 */
+Index: src/tcp_wrappers/inetcf.c
+diff -u src/tcp_wrappers/inetcf.c:1.1.1.1 src/tcp_wrappers/inetcf.c:1.2
+--- src/tcp_wrappers/inetcf.c:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/inetcf.c	Tue May  4 21:58:36 1999
+@@ -26,6 +26,9 @@
+   * guesses. Shorter names follow longer ones.
+   */
+ char   *inet_files[] = {
++#ifdef INET6
++    "/usr/local/v6/etc/inet6d.conf",	/* KAME */
++#endif
+     "/private/etc/inetd.conf",		/* NEXT */
+     "/etc/inet/inetd.conf",		/* SYSV4 */
+     "/usr/etc/inetd.conf",		/* IRIX?? */
+Index: src/tcp_wrappers/misc.c
+diff -u src/tcp_wrappers/misc.c:1.1.1.1 src/tcp_wrappers/misc.c:1.3
+--- src/tcp_wrappers/misc.c:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/misc.c	Fri Aug 13 20:09:20 1999
+@@ -10,6 +10,9 @@
+ 
+ #include <sys/types.h>
+ #include <sys/param.h>
++#if defined(INET6) && defined(linux)
++#include <sys/socket.h>
++#endif
+ #include <netinet/in.h>
+ #include <arpa/inet.h>
+ #include <stdio.h>
+@@ -58,9 +61,31 @@
+ {
+     char   *cp;
+ 
++#ifdef INET6
++    int bracket = 0;
++
++    for (cp = string; cp && *cp; cp++) {
++	switch (*cp) {
++	case '[':
++	    bracket++;
++	    break;
++	case ']':
++	    bracket--;
++	    break;
++	default:
++	    if (bracket == 0 && *cp == delimiter) {
++		*cp++ = 0;
++		return cp;
++	    }
++	    break;
++	}
++    }
++    return (NULL);
++#else
+     if ((cp = strchr(string, delimiter)) != 0)
+ 	*cp++ = 0;
+     return (cp);
++#endif
+ }
+ 
+ /* dot_quad_addr - convert dotted quad to internal form */
+Index: src/tcp_wrappers/refuse.c
+diff -u src/tcp_wrappers/refuse.c:1.1.1.1 src/tcp_wrappers/refuse.c:1.2
+--- src/tcp_wrappers/refuse.c:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/refuse.c	Tue May  4 21:58:36 1999
+@@ -25,7 +25,12 @@
+ void    refuse(request)
+ struct request_info *request;
+ {
++#ifdef INET6
++    syslog(deny_severity, "refused connect from %s (%s)",
++	   eval_client(request), eval_hostaddr(request->client));
++#else
+     syslog(deny_severity, "refused connect from %s", eval_client(request));
++#endif
+     clean_exit(request);
+     /* NOTREACHED */
+ }
+Index: src/tcp_wrappers/rfc931.c
+diff -u src/tcp_wrappers/rfc931.c:1.1.1.1 src/tcp_wrappers/rfc931.c:1.6
+--- src/tcp_wrappers/rfc931.c:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/rfc931.c	Fri Aug 13 20:08:06 1999
+@@ -68,20 +68,50 @@
+ /* rfc931 - return remote user name, given socket structures */
+ 
+ void    rfc931(rmt_sin, our_sin, dest)
++#ifdef INET6
++union tcpd_sockunion *rmt_sin;
++union tcpd_sockunion *our_sin;
++#else
+ struct sockaddr_in *rmt_sin;
+ struct sockaddr_in *our_sin;
++#endif
+ char   *dest;
+ {
+     unsigned rmt_port;
+     unsigned our_port;
++#ifdef INET6
++    union  tcpd_sockunion rmt_query_sin;
++    union  tcpd_sockunion our_query_sin;
++    int alen;
++#else
+     struct sockaddr_in rmt_query_sin;
+     struct sockaddr_in our_query_sin;
++#endif
+     char    user[256];			/* XXX */
+     char    buffer[512];		/* XXX */
+     char   *cp;
+     char   *result = unknown;
+     FILE   *fp;
+ 
++#ifdef INET6
++    /* address family must be the same */
++    if (rmt_sin->su_si.si_family != our_sin->su_si.si_family) {
++	STRN_CPY(dest, result, STRING_LENGTH);
++	return;
++    }
++    switch (rmt_sin->su_si.si_family) {
++    case AF_INET:
++	alen = sizeof(struct sockaddr_in);
++	break;
++    case AF_INET6:
++	alen = sizeof(struct sockaddr_in6);
++	break;
++    default:
++	STRN_CPY(dest, result, STRING_LENGTH);
++	return;
++    }
++#endif
++
+     /*
+      * Use one unbuffered stdio stream for writing to and for reading from
+      * the RFC931 etc. server. This is done because of a bug in the SunOS
+@@ -92,7 +122,11 @@
+      * sockets.
+      */
+ 
++#ifdef INET6
++    if ((fp = fsocket(our_sin->su_si.si_family, SOCK_STREAM, 0)) != 0) {
++#else
+     if ((fp = fsocket(AF_INET, SOCK_STREAM, 0)) != 0) {
++#endif
+ 	setbuf(fp, (char *) 0);
+ 
+ 	/*
+@@ -113,6 +147,14 @@
+ 	     */
+ 
+ 	    our_query_sin = *our_sin;
++#ifdef INET6
++	    our_query_sin.su_si.si_port = htons(ANY_PORT);
++	    rmt_query_sin = *rmt_sin;
++	    rmt_query_sin.su_si.si_port = htons(RFC931_PORT);
++
++	    if (bind(fileno(fp), &our_query_sin.su_sa, alen) >= 0 &&
++		connect(fileno(fp), &rmt_query_sin.su_sa, alen) >= 0) {
++#else
+ 	    our_query_sin.sin_port = htons(ANY_PORT);
+ 	    rmt_query_sin = *rmt_sin;
+ 	    rmt_query_sin.sin_port = htons(RFC931_PORT);
+@@ -121,6 +163,7 @@
+ 		     sizeof(our_query_sin)) >= 0 &&
+ 		connect(fileno(fp), (struct sockaddr *) & rmt_query_sin,
+ 			sizeof(rmt_query_sin)) >= 0) {
++#endif
+ 
+ 		/*
+ 		 * Send query to server. Neglect the risk that a 13-byte
+@@ -129,8 +172,13 @@
+ 		 */
+ 
+ 		fprintf(fp, "%u,%u\r\n",
++#ifdef INET6
++			ntohs(rmt_sin->su_si.si_port),
++			ntohs(our_sin->su_si.si_port));
++#else
+ 			ntohs(rmt_sin->sin_port),
+ 			ntohs(our_sin->sin_port));
++#endif
+ 		fflush(fp);
+ 
+ 		/*
+@@ -144,8 +192,13 @@
+ 		    && ferror(fp) == 0 && feof(fp) == 0
+ 		    && sscanf(buffer, "%u , %u : USERID :%*[^:]:%255s",
+ 			      &rmt_port, &our_port, user) == 3
++#ifdef INET6
++		    && ntohs(rmt_sin->su_si.si_port) == rmt_port
++		    && ntohs(our_sin->su_si.si_port) == our_port) {
++#else
+ 		    && ntohs(rmt_sin->sin_port) == rmt_port
+ 		    && ntohs(our_sin->sin_port) == our_port) {
++#endif
+ 
+ 		    /*
+ 		     * Strip trailing carriage return. It is part of the
+Index: src/tcp_wrappers/scaffold.c
+diff -u src/tcp_wrappers/scaffold.c:1.1.1.1 src/tcp_wrappers/scaffold.c:1.7
+--- src/tcp_wrappers/scaffold.c:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/scaffold.c	Fri Aug 13 22:22:35 1999
+@@ -20,6 +20,9 @@
+ #include <syslog.h>
+ #include <setjmp.h>
+ #include <string.h>
++#if defined(INET6) && !defined(USE_GETIPNODEBY)
++#include <resolv.h>
++#endif
+ 
+ #ifndef INADDR_NONE
+ #define	INADDR_NONE	(-1)		/* XXX should be 0xffffffff */
+@@ -57,6 +60,9 @@
+ 	 /* void */ ;
+ 
+     if ((hb = (struct hostent_block *) malloc(sizeof(struct hostent_block)
++#ifdef INET6
++			 + strlen(hp->h_name) + 1
++#endif
+ 			 + (hp->h_length + sizeof(char *)) * count)) == 0) {
+ 	fprintf(stderr, "Sorry, out of memory\n");
+ 	exit(1);
+@@ -66,6 +72,11 @@
+     hb->host.h_addr_list = hb->addr_list;
+     hb->host.h_addr_list[count] = 0;
+     data = (char *) (hb->host.h_addr_list + count + 1);
++#ifdef INET6
++    hb->host.h_name = data + hp->h_length * count;
++    strcpy(hb->host.h_name, hp->h_name);
++    hb->host.h_addrtype = hp->h_addrtype;
++#endif
+ 
+     for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
+ 	hb->host.h_addr_list[count] = data + hp->h_length * count;
+@@ -74,6 +85,97 @@
+     return (&hb->host);
+ }
+ 
++#if defined(INET6) && !defined(USE_GETIPNODEBY)
++/* merge_hostent - merge hostent in one memory block */
++
++static struct hostent *merge_hostent(hp1, hp2)
++struct hostent *hp1, *hp2;
++{
++    struct hostent_block {
++	struct hostent host;
++	char   *addr_list[1];
++    };
++    struct hostent_block *hb;
++    int     count, count2;
++    char   *data;
++    char   *addr;
++
++    for (count = 0; hp1->h_addr_list[count] != 0; count++)
++	 /* void */ ;
++    for (count2 = 0; hp2->h_addr_list[count2] != 0; count2++)
++	 /* void */ ;
++    count += count2;
++
++    if ((hb = (struct hostent_block *) malloc(sizeof(struct hostent_block)
++			 + strlen(hp1->h_name) + 1
++			 + (hp1->h_length + sizeof(char *)) * count)) == 0) {
++	fprintf(stderr, "Sorry, out of memory\n");
++	exit(1);
++    }
++    memset((char *) &hb->host, 0, sizeof(hb->host));
++    hb->host.h_length = hp1->h_length;
++    hb->host.h_addr_list = hb->addr_list;
++    hb->host.h_addr_list[count] = 0;
++    data = (char *) (hb->host.h_addr_list + count + 1);
++    hb->host.h_name = data + hp1->h_length * count;
++    strcpy(hb->host.h_name, hp1->h_name);
++    hb->host.h_addrtype = hp1->h_addrtype;
++
++    for (count = 0; (addr = hp1->h_addr_list[count]) != 0; count++) {
++	hb->host.h_addr_list[count] = data + hp1->h_length * count;
++	memcpy(hb->host.h_addr_list[count], addr, hp1->h_length);
++    }
++    for (count2 = 0; (addr = hp2->h_addr_list[count2]) != 0; count2++) {
++	hb->host.h_addr_list[count] = data + hp1->h_length * count;
++	memcpy(hb->host.h_addr_list[count], addr, hp1->h_length);
++	++count;
++    }
++    return (&hb->host);
++}
++#endif
++
++static struct hostent *gethostbyname64(host)
++char *host;
++{
++    struct hostent *hp, *hp2;
++#ifdef USE_GETIPNODEBY
++    int h_error;
++
++    if ((hp = getipnodebyname(host, AF_INET6,
++			      AI_V4MAPPED | AI_ADDRCONFIG | AI_ALL,
++			      &h_error)) != 0) {
++	hp2 = dup_hostent(hp);
++	freehostent(hp);
++	return (hp2);
++    }
++#else
++    struct hostent *hp1;
++
++    if ((_res.options & RES_INIT) == 0) {
++	if (res_init() < 0) {
++	    tcpd_warn("%s: res_init() failed", host);
++	    return (NULL);
++	}
++    }
++    _res.options |= RES_USE_INET6;
++    if ((hp1 = gethostbyname2(host, AF_INET6)) != NULL)
++	hp1 = dup_hostent(hp1);
++    if ((hp2 = gethostbyname2(host, AF_INET)) != NULL)
++	hp2 = dup_hostent(hp2);
++    if (hp1 && hp2) {
++	hp = merge_hostent(hp1, hp2);
++	free((char *) hp1);
++	free((char *) hp2);
++	return (hp);
++    }
++    if (hp1)
++	return (hp1);
++    if (hp2)
++	return (hp2);
++#endif
++    return (NULL);
++}
++
+ /* find_inet_addr - find all addresses for this host, result to free() */
+ 
+ struct hostent *find_inet_addr(host)
+@@ -91,6 +193,9 @@
+ 	h.h_addr_list = addr_list;
+ 	h.h_addr_list[0] = (char *) &addr;
+ 	h.h_length = sizeof(addr);
++#ifdef INET6
++	h.h_addrtype = AF_INET;
++#endif
+ 	return (dup_hostent(&h));
+     }
+ 
+@@ -104,19 +209,33 @@
+ 	tcpd_warn("%s: not an internet address", host);
+ 	return (0);
+     }
++#ifdef INET6
++    if ((hp = gethostbyname64(host)) == 0) {
++#else
+     if ((hp = gethostbyname(host)) == 0) {
++#endif
+ 	tcpd_warn("%s: host not found", host);
+ 	return (0);
+     }
++#ifdef INET6
++    if (hp->h_addrtype != AF_INET6) {
++	tcpd_warn("%d: not an internet host", hp->h_addrtype);
++	free((char *) hp);
++#else
+     if (hp->h_addrtype != AF_INET) {
+ 	tcpd_warn("%d: not an internet host", hp->h_addrtype);
++#endif
+ 	return (0);
+     }
+     if (STR_NE(host, hp->h_name)) {
+ 	tcpd_warn("%s: hostname alias", host);
+ 	tcpd_warn("(official name: %.*s)", STRING_LENGTH, hp->h_name);
+     }
++#ifdef INET6
++    return (hp);
++#else
+     return (dup_hostent(hp));
++#endif
+ }
+ 
+ /* check_dns - give each address thorough workout, return address count */
+@@ -125,7 +244,13 @@
+ char   *host;
+ {
+     struct request_info request;
++#ifdef INET6
++    union tcpd_sockunion sin;
++    char *ap;
++    int alen;
++#else
+     struct sockaddr_in sin;
++#endif
+     struct hostent *hp;
+     int     count;
+     char   *addr;
+@@ -135,10 +260,30 @@
+     request_init(&request, RQ_CLIENT_SIN, &sin, 0);
+     sock_methods(&request);
+     memset((char *) &sin, 0, sizeof(sin));
++#ifdef INET6
++    sin.su_si.si_family = hp->h_addrtype;
++    switch (hp->h_addrtype) {
++    case AF_INET:
++	ap = (char *)&sin.su_sin.sin_addr;
++	alen = sizeof(struct sockaddr_in);
++	break;
++    case AF_INET6:
++	ap = (char *)&sin.su_sin6.sin6_addr;
++	alen = sizeof(struct sockaddr_in6);
++	break;
++    default:
++	return (0);
++    }
++#else
+     sin.sin_family = AF_INET;
++#endif
+ 
+     for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
++#ifdef INET6
++	memcpy(ap, addr, alen);
++#else
+ 	memcpy((char *) &sin.sin_addr, addr, sizeof(sin.sin_addr));
++#endif
+ 
+ 	/*
+ 	 * Force host name and address conversions. Use the request structure
+Index: src/tcp_wrappers/socket.c
+diff -u src/tcp_wrappers/socket.c:1.1.1.1 src/tcp_wrappers/socket.c:1.12
+--- src/tcp_wrappers/socket.c:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/socket.c	Fri Aug 13 20:08:06 1999
+@@ -30,6 +30,12 @@
+ #include <syslog.h>
+ #include <string.h>
+ 
++#ifdef INET6
++#ifndef USE_GETIPNODEBY
++#include <resolv.h>
++#endif
++#endif
++
+ extern char *inet_ntoa();
+ 
+ /* Local stuff. */
+@@ -74,8 +80,13 @@
+ void    sock_host(request)
+ struct request_info *request;
+ {
++#ifdef INET6
++    static union tcpd_sockunion client;
++    static union tcpd_sockunion server;
++#else
+     static struct sockaddr_in client;
+     static struct sockaddr_in server;
++#endif
+     int     len;
+     char    buf[BUFSIZ];
+     int     fd = request->fd;
+@@ -125,10 +136,33 @@
+ void    sock_hostaddr(host)
+ struct host_info *host;
+ {
++#ifdef INET6
++    union tcpd_sockunion *sin = host->sin;
++    int alen;
++    char *ap;
++
++    if (!sin)
++	return;
++    switch (sin->su_si.si_family) {
++    case AF_INET:
++	ap = (char *)&sin->su_sin.sin_addr;
++	alen = sizeof(struct in_addr);
++	break;
++    case AF_INET6:
++	ap = (char *)&sin->su_sin6.sin6_addr;
++	alen = sizeof(struct in6_addr);
++	break;
++    default:
++	return;
++    }
++    host->addr[0] = '\0';
++    inet_ntop(sin->su_si.si_family, ap, host->addr, sizeof(host->addr));
++#else
+     struct sockaddr_in *sin = host->sin;
+ 
+     if (sin != 0)
+ 	STRN_CPY(host->addr, inet_ntoa(sin->sin_addr), sizeof(host->addr));
++#endif
+ }
+ 
+ /* sock_hostname - map endpoint address to host name */
+@@ -136,8 +170,19 @@
+ void    sock_hostname(host)
+ struct host_info *host;
+ {
++#ifdef INET6
++    union tcpd_sockunion *sin = host->sin;
++    char addr[128];
++#ifdef USE_GETIPNODEBY
++    int h_error;
++#endif
++    struct hostent *hp = NULL;
++    char *ap;
++    int alen;
++#else
+     struct sockaddr_in *sin = host->sin;
+     struct hostent *hp;
++#endif
+     int     i;
+ 
+     /*
+@@ -147,11 +192,57 @@
+      * have to special-case 0.0.0.0, in order to avoid false alerts from the
+      * host name/address checking code below.
+      */
++#ifdef INET6
++    if (sin != NULL) {
++	switch (sin->su_si.si_family) {
++	case AF_INET:
++	    if (sin->su_sin.sin_addr.s_addr == 0) {
++		strcpy(host->name, paranoid);	/* name is bad, clobber it */
++		return;
++	    }
++	    ap = (char *) &sin->su_sin.sin_addr;
++	    alen = sizeof(struct in_addr);
++	    break;
++	case AF_INET6:
++	    ap = (char *) &sin->su_sin6.sin6_addr;
++	    alen = sizeof(struct in6_addr);
++	    break;
++	defalut:
++	    strcpy(host->name, paranoid);	/* name is bad, clobber it */
++	    return;
++	}
++#ifndef USE_GETIPNODEBY
++	if ((_res.options & RES_INIT) == 0) {
++	    if (res_init() < 0) {
++		inet_ntop(sin->su_si.si_family, ap, addr, sizeof(addr));
++		tcpd_warn("can't verify hostname: res_init() for %s failed",
++			  addr);
++		strcpy(host->name, paranoid);	/* name is bad, clobber it */
++		return;
++	    }
++	}
++	if (sin->su_si.si_family == AF_INET6)
++	    _res.options |= RES_USE_INET6;
++	else
++	    _res.options &= ~RES_USE_INET6;
++#endif
++#ifdef USE_GETIPNODEBY
++	hp = getipnodebyaddr(ap, alen, sin->su_si.si_family, &h_error);
++#else
++	hp = gethostbyaddr(ap, alen, sin->su_si.si_family);
++#endif
++    }
++    if (hp) {
++#else
+     if (sin != 0 && sin->sin_addr.s_addr != 0
+ 	&& (hp = gethostbyaddr((char *) &(sin->sin_addr),
+ 			       sizeof(sin->sin_addr), AF_INET)) != 0) {
++#endif
+ 
+ 	STRN_CPY(host->name, hp->h_name, sizeof(host->name));
++#if defined(INET6) && defined(USE_GETIPNODEBY)
++	freehostent(hp);
++#endif
+ 
+ 	/*
+ 	 * Verify that the address is a member of the address list returned
+@@ -166,15 +257,39 @@
+ 	 * we're in big trouble anyway.
+ 	 */
+ 
++#ifdef INET6
++#ifdef USE_GETIPNODEBY
++	hp = getipnodebyname(host->name, sin->su_si.si_family,
++			     AI_V4MAPPED | AI_ADDRCONFIG | AI_ALL, &h_error);
++#else
++	hp = gethostbyname2(host->name,
++			    (sin->su_si.si_family == AF_INET6 &&
++			     IN6_IS_ADDR_V4MAPPED(&sin->su_sin6.sin6_addr)) ?
++				AF_INET : sin->su_si.si_family);
++#endif
++	if (!hp) {
++#else
+ 	if ((hp = gethostbyname(host->name)) == 0) {
++#endif
+ 
+ 	    /*
+ 	     * Unable to verify that the host name matches the address. This
+ 	     * may be a transient problem or a botched name server setup.
+ 	     */
+ 
++#ifdef INET6
++#ifdef USE_GETIPNODEBY
++	    tcpd_warn("can't verify hostname: getipnodebyname(%s, %s) failed",
++#else
++	    tcpd_warn("can't verify hostname: gethostbyname2(%s, %s) failed",
++#endif
++		      host->name,
++		      (sin->su_si.si_family == AF_INET) ?
++			  "AF_INET" : "AF_INET6");
++#else
+ 	    tcpd_warn("can't verify hostname: gethostbyname(%s) failed",
+ 		      host->name);
++#endif
+ 
+ 	} else if (STR_NE(host->name, hp->h_name)
+ 		   && STR_NE(host->name, "localhost")) {
+@@ -198,10 +313,19 @@
+ 	     */
+ 
+ 	    for (i = 0; hp->h_addr_list[i]; i++) {
++#ifdef INET6
++		if (memcmp(hp->h_addr_list[i], ap, alen) == 0) {
++#ifdef USE_GETIPNODEBY
++		    freehostent(hp);
++#endif
++		    return;			/* name is good, keep it */
++		}
++#else
+ 		if (memcmp(hp->h_addr_list[i],
+ 			   (char *) &sin->sin_addr,
+ 			   sizeof(sin->sin_addr)) == 0)
+ 		    return;			/* name is good, keep it */
++#endif
+ 	    }
+ 
+ 	    /*
+@@ -210,10 +334,20 @@
+ 	     * server.
+ 	     */
+ 
++#ifdef INET6
++	    inet_ntop(sin->su_si.si_family, ap, addr, sizeof(addr));
++	    tcpd_warn("host name/address mismatch: %s != %.*s",
++		      addr, STRING_LENGTH, hp->h_name);
++#else
+ 	    tcpd_warn("host name/address mismatch: %s != %.*s",
+ 		      inet_ntoa(sin->sin_addr), STRING_LENGTH, hp->h_name);
++#endif
+ 	}
+ 	strcpy(host->name, paranoid);		/* name is bad, clobber it */
++#if defined(INET6) && defined(USE_GETIPNODEBY)
++	if (hp)
++	    freehostent(hp);
++#endif
+     }
+ }
+ 
+@@ -223,7 +357,11 @@
+ int     fd;
+ {
+     char    buf[BUFSIZ];
++#ifdef INET6
++    union tcpd_sockunion sin;
++#else
+     struct sockaddr_in sin;
++#endif
+     int     size = sizeof(sin);
+ 
+     /*
+Index: src/tcp_wrappers/tcpd.c
+diff -u src/tcp_wrappers/tcpd.c:1.1.1.1 src/tcp_wrappers/tcpd.c:1.2
+--- src/tcp_wrappers/tcpd.c:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/tcpd.c	Tue May  4 21:58:36 1999
+@@ -120,7 +120,12 @@
+ 
+     /* Report request and invoke the real daemon program. */
+ 
++#ifdef INET6
++    syslog(allow_severity, "connect from %s (%s)",
++	   eval_client(&request), eval_hostaddr(request.client));
++#else
+     syslog(allow_severity, "connect from %s", eval_client(&request));
++#endif
+     closelog();
+     (void) execv(path, argv);
+     syslog(LOG_ERR, "error: cannot execute %s: %m", path);
+Index: src/tcp_wrappers/tcpd.h
+diff -u src/tcp_wrappers/tcpd.h:1.1.1.1 src/tcp_wrappers/tcpd.h:1.6
+--- src/tcp_wrappers/tcpd.h:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/tcpd.h	Fri Aug 13 21:28:06 1999
+@@ -8,10 +8,35 @@
+ 
+ #define STRING_LENGTH	128		/* hosts, users, processes */
+ 
++#ifdef INET6
++#include <sys/types.h>
++#include <sys/socket.h>
++#include <netinet/in.h>
++
++union tcpd_sockunion {
++    struct tcpd_sockinet {
++#ifdef SIN6_LEN
++	u_char si_len;
++	u_char si_family;
++#else
++	sa_family_t si_family;
++#endif
++	u_short si_port;
++    } su_si;
++    struct sockaddr     su_sa;
++    struct sockaddr_in  su_sin;
++    struct sockaddr_in6 su_sin6;
++};
++#endif
++
+ struct host_info {
+     char    name[STRING_LENGTH];	/* access via eval_hostname(host) */
+     char    addr[STRING_LENGTH];	/* access via eval_hostaddr(host) */
++#ifdef INET6
++    union tcpd_sockunion *sin;		/* socket address or 0 */
++#else
+     struct sockaddr_in *sin;		/* socket address or 0 */
++#endif
+     struct t_unitdata *unit;		/* TLI transport address or 0 */
+     struct request_info *request;	/* for shared information */
+ };
+Index: src/tcp_wrappers/tcpdchk.c
+diff -u src/tcp_wrappers/tcpdchk.c:1.1.1.1 src/tcp_wrappers/tcpdchk.c:1.4
+--- src/tcp_wrappers/tcpdchk.c:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/tcpdchk.c	Sat Aug 14 04:02:26 1999
+@@ -22,6 +22,9 @@
+ 
+ #include <sys/types.h>
+ #include <sys/stat.h>
++#ifdef INET6
++#include <sys/socket.h>
++#endif
+ #include <netinet/in.h>
+ #include <arpa/inet.h>
+ #include <stdio.h>
+@@ -397,6 +400,26 @@
+     }
+ }
+ 
++#ifdef INET6
++static int is_inet6_addr(pat)
++    char *pat;
++{
++    struct in6_addr addr;
++    int len, ret;
++    char ch;
++
++    if (*pat != '[')
++	return (0);
++    len = strlen(pat);
++    if ((ch = pat[len - 1]) != ']')
++	return (0);
++    pat[len - 1] = '\0';
++    ret = inet_pton(AF_INET6, pat + 1, &addr);
++    pat[len - 1] = ch;
++    return (ret == 1);
++}
++#endif
++
+ /* check_host - criticize host pattern */
+ 
+ static int check_host(pat)
+@@ -423,14 +446,27 @@
+ #endif
+ #endif
+     } else if (mask = split_at(pat, '/')) {	/* network/netmask */
++#ifdef INET6
++	int mask_len;
++
++	if ((dot_quad_addr(pat) == INADDR_NONE
++	    || dot_quad_addr(mask) == INADDR_NONE)
++	    && (!is_inet6_addr(pat)
++		|| ((mask_len = atoi(mask)) < 0 || mask_len > 128)))
++#else
+ 	if (dot_quad_addr(pat) == INADDR_NONE
+ 	    || dot_quad_addr(mask) == INADDR_NONE)
++#endif
+ 	    tcpd_warn("%s/%s: bad net/mask pattern", pat, mask);
+     } else if (STR_EQ(pat, "FAIL")) {		/* obsolete */
+ 	tcpd_warn("FAIL is no longer recognized");
+ 	tcpd_warn("(use EXCEPT or DENY instead)");
+     } else if (reserved_name(pat)) {		/* other reserved */
+ 	 /* void */ ;
++#ifdef INET6
++    } else if (is_inet6_addr(pat)) { /* IPv6 address */
++	addr_count = 1;
++#endif
+     } else if (NOT_INADDR(pat)) {		/* internet name */
+ 	if (pat[strlen(pat) - 1] == '.') {
+ 	    tcpd_warn("%s: domain or host name ends in dot", pat);
+Index: src/tcp_wrappers/tcpdmatch.c
+diff -u src/tcp_wrappers/tcpdmatch.c:1.1.1.1 src/tcp_wrappers/tcpdmatch.c:1.4
+--- src/tcp_wrappers/tcpdmatch.c:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/tcpdmatch.c	Fri Aug 13 22:22:35 1999
+@@ -68,8 +68,15 @@
+     int     ch;
+     char   *inetcf = 0;
+     int     count;
++#ifdef INET6
++    union tcpd_sockunion server_sin;
++    union tcpd_sockunion client_sin;
++    char *ap;
++    int alen;
++#else
+     struct sockaddr_in server_sin;
+     struct sockaddr_in client_sin;
++#endif
+     struct stat st;
+ 
+     /*
+@@ -173,12 +180,35 @@
+ 	if ((hp = find_inet_addr(server)) == 0)
+ 	    exit(1);
+ 	memset((char *) &server_sin, 0, sizeof(server_sin));
++#ifdef INET6
++	server_sin.su_si.si_family = hp->h_addrtype;
++	switch (hp->h_addrtype) {
++	case AF_INET:
++	    ap = (char *)&server_sin.su_sin.sin_addr;
++	    alen = sizeof(struct sockaddr_in);
++	    break;
++	case AF_INET6:
++	    ap = (char *)&server_sin.su_sin6.sin6_addr;
++	    alen = sizeof(struct sockaddr_in6);
++	    break;
++	default:
++	    exit(1);
++	}
++#ifdef SIN6_LEN
++	server_sin.su_si.si_len = alen;
++#endif
++#else
+ 	server_sin.sin_family = AF_INET;
++#endif
+ 	request_set(&request, RQ_SERVER_SIN, &server_sin, 0);
+ 
+ 	for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
++#ifdef INET6
++	    memcpy(ap, addr, alen);
++#else
+ 	    memcpy((char *) &server_sin.sin_addr, addr,
+ 		   sizeof(server_sin.sin_addr));
++#endif
+ 
+ 	    /*
+ 	     * Force evaluation of server host name and address. Host name
+@@ -230,12 +260,35 @@
+     if ((hp = find_inet_addr(client)) == 0)
+ 	exit(1);
+     memset((char *) &client_sin, 0, sizeof(client_sin));
++#ifdef INET6
++    client_sin.su_si.si_family = hp->h_addrtype;
++    switch (hp->h_addrtype) {
++    case AF_INET:
++	ap = (char *)&client_sin.su_sin.sin_addr;
++	alen = sizeof(struct sockaddr_in);
++	break;
++    case AF_INET6:
++	ap = (char *)&client_sin.su_sin6.sin6_addr;
++	alen = sizeof(struct sockaddr_in6);
++	break;
++    default:
++	exit(1);
++    }
++#ifdef SIN6_LEN
++    client_sin.su_si.si_len = alen;
++#endif
++#else
+     client_sin.sin_family = AF_INET;
++#endif
+     request_set(&request, RQ_CLIENT_SIN, &client_sin, 0);
+ 
+     for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
++#ifdef INET6
++	memcpy(ap, addr, alen);
++#else
+ 	memcpy((char *) &client_sin.sin_addr, addr,
+ 	       sizeof(client_sin.sin_addr));
++#endif
+ 
+ 	/*
+ 	 * Force evaluation of client host name and address. Host name
+Index: src/tcp_wrappers/update.c
+diff -u src/tcp_wrappers/update.c:1.1.1.1 src/tcp_wrappers/update.c:1.2
+--- src/tcp_wrappers/update.c:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/update.c	Tue May  4 21:58:36 1999
+@@ -46,10 +46,18 @@
+ 	    request->fd = va_arg(ap, int);
+ 	    continue;
+ 	case RQ_CLIENT_SIN:
++#ifdef INET6
++	    request->client->sin = va_arg(ap, union tcpd_sockunion *);
++#else
+ 	    request->client->sin = va_arg(ap, struct sockaddr_in *);
++#endif
+ 	    continue;
+ 	case RQ_SERVER_SIN:
++#ifdef INET6
++	    request->server->sin = va_arg(ap, union tcpd_sockunion *);
++#else
+ 	    request->server->sin = va_arg(ap, struct sockaddr_in *);
++#endif
+ 	    continue;
+ 
+ 	    /*
+Index: src/tcp_wrappers/workarounds.c
+diff -u src/tcp_wrappers/workarounds.c:1.1.1.1 src/tcp_wrappers/workarounds.c:1.2
+--- src/tcp_wrappers/workarounds.c:1.1.1.1	Tue May  4 21:56:04 1999
++++ src/tcp_wrappers/workarounds.c	Tue May  4 21:58:36 1999
+@@ -166,11 +166,22 @@
+ int    *len;
+ {
+     int     ret;
++#ifdef INET6
++    union tcpd_sockunion *sin = (union tcpd_sockunion *) sa;
++#else
+     struct sockaddr_in *sin = (struct sockaddr_in *) sa;
++#endif
+ 
+     if ((ret = getpeername(sock, sa, len)) >= 0
++#ifdef INET6
++	&& ((sin->su_si.si_family == AF_INET6
++	     && IN6_IS_ADDR_UNSPECIFIED(&sin->su_sin6.sin6_addr))
++	    || (sin->su_si.si_family == AF_INET
++		&& sin->su_sin.sin_addr.s_addr == 0))) {
++#else
+ 	&& sa->sa_family == AF_INET
+ 	&& sin->sin_addr.s_addr == 0) {
++#endif
+ 	errno = ENOTCONN;
+ 	return (-1);
+     } else {
diff -urN tcp_wrappers_7.6.orig/tcpd.c tcp_wrappers_7.6/tcpd.c
--- tcp_wrappers_7.6.orig/tcpd.c	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/tcpd.c	Thu Aug 19 16:44:32 1999
@@ -120,7 +120,12 @@
 
     /* Report request and invoke the real daemon program. */
 
+#ifdef INET6
+    syslog(allow_severity, "connect from %s (%s)",
+	   eval_client(&request), eval_hostaddr(request.client));
+#else
     syslog(allow_severity, "connect from %s", eval_client(&request));
+#endif
     closelog();
     (void) execv(path, argv);
     syslog(LOG_ERR, "error: cannot execute %s: %m", path);
diff -urN tcp_wrappers_7.6.orig/tcpd.h tcp_wrappers_7.6/tcpd.h
--- tcp_wrappers_7.6.orig/tcpd.h	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/tcpd.h	Thu Aug 19 16:44:32 1999
@@ -8,10 +8,35 @@
 
 #define STRING_LENGTH	128		/* hosts, users, processes */
 
+#ifdef INET6
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+union tcpd_sockunion {
+    struct tcpd_sockinet {
+#ifdef SIN6_LEN
+	u_char si_len;
+	u_char si_family;
+#else
+	sa_family_t si_family;
+#endif
+	u_short si_port;
+    } su_si;
+    struct sockaddr     su_sa;
+    struct sockaddr_in  su_sin;
+    struct sockaddr_in6 su_sin6;
+};
+#endif
+
 struct host_info {
     char    name[STRING_LENGTH];	/* access via eval_hostname(host) */
     char    addr[STRING_LENGTH];	/* access via eval_hostaddr(host) */
+#ifdef INET6
+    union tcpd_sockunion *sin;		/* socket address or 0 */
+#else
     struct sockaddr_in *sin;		/* socket address or 0 */
+#endif
     struct t_unitdata *unit;		/* TLI transport address or 0 */
     struct request_info *request;	/* for shared information */
 };
diff -urN tcp_wrappers_7.6.orig/tcpdchk.c tcp_wrappers_7.6/tcpdchk.c
--- tcp_wrappers_7.6.orig/tcpdchk.c	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/tcpdchk.c	Thu Aug 19 16:44:32 1999
@@ -22,6 +22,9 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#ifdef INET6
+#include <sys/socket.h>
+#endif
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <stdio.h>
@@ -397,6 +400,26 @@
     }
 }
 
+#ifdef INET6
+static int is_inet6_addr(pat)
+    char *pat;
+{
+    struct in6_addr addr;
+    int len, ret;
+    char ch;
+
+    if (*pat != '[')
+	return (0);
+    len = strlen(pat);
+    if ((ch = pat[len - 1]) != ']')
+	return (0);
+    pat[len - 1] = '\0';
+    ret = inet_pton(AF_INET6, pat + 1, &addr);
+    pat[len - 1] = ch;
+    return (ret == 1);
+}
+#endif
+
 /* check_host - criticize host pattern */
 
 static int check_host(pat)
@@ -423,14 +446,27 @@
 #endif
 #endif
     } else if (mask = split_at(pat, '/')) {	/* network/netmask */
+#ifdef INET6
+	int mask_len;
+
+	if ((dot_quad_addr(pat) == INADDR_NONE
+	    || dot_quad_addr(mask) == INADDR_NONE)
+	    && (!is_inet6_addr(pat)
+		|| ((mask_len = atoi(mask)) < 0 || mask_len > 128)))
+#else
 	if (dot_quad_addr(pat) == INADDR_NONE
 	    || dot_quad_addr(mask) == INADDR_NONE)
+#endif
 	    tcpd_warn("%s/%s: bad net/mask pattern", pat, mask);
     } else if (STR_EQ(pat, "FAIL")) {		/* obsolete */
 	tcpd_warn("FAIL is no longer recognized");
 	tcpd_warn("(use EXCEPT or DENY instead)");
     } else if (reserved_name(pat)) {		/* other reserved */
 	 /* void */ ;
+#ifdef INET6
+    } else if (is_inet6_addr(pat)) { /* IPv6 address */
+	addr_count = 1;
+#endif
     } else if (NOT_INADDR(pat)) {		/* internet name */
 	if (pat[strlen(pat) - 1] == '.') {
 	    tcpd_warn("%s: domain or host name ends in dot", pat);
diff -urN tcp_wrappers_7.6.orig/tcpdmatch.c tcp_wrappers_7.6/tcpdmatch.c
--- tcp_wrappers_7.6.orig/tcpdmatch.c	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/tcpdmatch.c	Thu Aug 19 16:44:32 1999
@@ -68,8 +68,15 @@
     int     ch;
     char   *inetcf = 0;
     int     count;
+#ifdef INET6
+    union tcpd_sockunion server_sin;
+    union tcpd_sockunion client_sin;
+    char *ap;
+    int alen;
+#else
     struct sockaddr_in server_sin;
     struct sockaddr_in client_sin;
+#endif
     struct stat st;
 
     /*
@@ -173,12 +180,35 @@
 	if ((hp = find_inet_addr(server)) == 0)
 	    exit(1);
 	memset((char *) &server_sin, 0, sizeof(server_sin));
+#ifdef INET6
+	server_sin.su_si.si_family = hp->h_addrtype;
+	switch (hp->h_addrtype) {
+	case AF_INET:
+	    ap = (char *)&server_sin.su_sin.sin_addr;
+	    alen = sizeof(struct sockaddr_in);
+	    break;
+	case AF_INET6:
+	    ap = (char *)&server_sin.su_sin6.sin6_addr;
+	    alen = sizeof(struct sockaddr_in6);
+	    break;
+	default:
+	    exit(1);
+	}
+#ifdef SIN6_LEN
+	server_sin.su_si.si_len = alen;
+#endif
+#else
 	server_sin.sin_family = AF_INET;
+#endif
 	request_set(&request, RQ_SERVER_SIN, &server_sin, 0);
 
 	for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
+#ifdef INET6
+	    memcpy(ap, addr, alen);
+#else
 	    memcpy((char *) &server_sin.sin_addr, addr,
 		   sizeof(server_sin.sin_addr));
+#endif
 
 	    /*
 	     * Force evaluation of server host name and address. Host name
@@ -230,12 +260,35 @@
     if ((hp = find_inet_addr(client)) == 0)
 	exit(1);
     memset((char *) &client_sin, 0, sizeof(client_sin));
+#ifdef INET6
+    client_sin.su_si.si_family = hp->h_addrtype;
+    switch (hp->h_addrtype) {
+    case AF_INET:
+	ap = (char *)&client_sin.su_sin.sin_addr;
+	alen = sizeof(struct sockaddr_in);
+	break;
+    case AF_INET6:
+	ap = (char *)&client_sin.su_sin6.sin6_addr;
+	alen = sizeof(struct sockaddr_in6);
+	break;
+    default:
+	exit(1);
+    }
+#ifdef SIN6_LEN
+    client_sin.su_si.si_len = alen;
+#endif
+#else
     client_sin.sin_family = AF_INET;
+#endif
     request_set(&request, RQ_CLIENT_SIN, &client_sin, 0);
 
     for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
+#ifdef INET6
+	memcpy(ap, addr, alen);
+#else
 	memcpy((char *) &client_sin.sin_addr, addr,
 	       sizeof(client_sin.sin_addr));
+#endif
 
 	/*
 	 * Force evaluation of client host name and address. Host name
diff -urN tcp_wrappers_7.6.orig/update.c tcp_wrappers_7.6/update.c
--- tcp_wrappers_7.6.orig/update.c	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/update.c	Thu Aug 19 16:44:32 1999
@@ -46,10 +46,18 @@
 	    request->fd = va_arg(ap, int);
 	    continue;
 	case RQ_CLIENT_SIN:
+#ifdef INET6
+	    request->client->sin = va_arg(ap, union tcpd_sockunion *);
+#else
 	    request->client->sin = va_arg(ap, struct sockaddr_in *);
+#endif
 	    continue;
 	case RQ_SERVER_SIN:
+#ifdef INET6
+	    request->server->sin = va_arg(ap, union tcpd_sockunion *);
+#else
 	    request->server->sin = va_arg(ap, struct sockaddr_in *);
+#endif
 	    continue;
 
 	    /*
diff -urN tcp_wrappers_7.6.orig/workarounds.c tcp_wrappers_7.6/workarounds.c
--- tcp_wrappers_7.6.orig/workarounds.c	Thu Aug 19 16:44:08 1999
+++ tcp_wrappers_7.6/workarounds.c	Thu Aug 19 16:44:32 1999
@@ -170,11 +170,22 @@
 #endif
 {
     int     ret;
+#ifdef INET6
+    union tcpd_sockunion *sin = (union tcpd_sockunion *) sa;
+#else
     struct sockaddr_in *sin = (struct sockaddr_in *) sa;
+#endif
 
     if ((ret = getpeername(sock, sa, len)) >= 0
+#ifdef INET6
+	&& ((sin->su_si.si_family == AF_INET6
+	     && IN6_IS_ADDR_UNSPECIFIED(&sin->su_sin6.sin6_addr))
+	    || (sin->su_si.si_family == AF_INET
+		&& sin->su_sin.sin_addr.s_addr == 0))) {
+#else
 	&& sa->sa_family == AF_INET
 	&& sin->sin_addr.s_addr == 0) {
+#endif
 	errno = ENOTCONN;
 	return (-1);
     } else {
